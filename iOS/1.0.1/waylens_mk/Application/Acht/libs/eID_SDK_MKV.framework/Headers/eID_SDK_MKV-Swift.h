#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
#ifndef EID_SDK_MKV_SWIFT_H
#define EID_SDK_MKV_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wduplicate-method-match"
#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT noexcept
#endif
#else
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT 
#endif
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_CXX_INT_DEFINED)
#define SWIFT_CXX_INT_DEFINED
namespace swift {
using Int = ptrdiff_t;
using UInt = size_t;
}
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreFoundation;
@import Darwin;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="eID_SDK_MKV",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class NSData;
@class NSString;

SWIFT_CLASS("_TtC11eID_SDK_MKV8CardInfo")
@interface CardInfo : NSObject
@property (nonatomic, copy) NSData * _Nullable imageData;
@property (nonatomic, copy) NSString * _Nonnull IDNumber;
@property (nonatomic, copy) NSString * _Nonnull FullName;
@property (nonatomic, copy) NSString * _Nonnull DOB;
@property (nonatomic, copy) NSString * _Nonnull Gender;
@property (nonatomic, copy) NSString * _Nonnull Nationality;
@property (nonatomic, copy) NSString * _Nonnull Hometown;
@property (nonatomic, copy) NSString * _Nonnull Resident;
@property (nonatomic, copy) NSString * _Nonnull DDND;
@property (nonatomic, copy) NSString * _Nonnull ValidDate;
@property (nonatomic, copy) NSString * _Nonnull ExpiredDate;
@property (nonatomic, copy) NSString * _Nonnull OldIDNumber;
@property (nonatomic, copy) NSString * _Nonnull transactionId;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum DYFSwiftKeychainAccessOptions : uint8_t;

/// The class for swift keychain wrapper.
SWIFT_CLASS("_TtC11eID_SDK_MKV16DYFSwiftKeychain")
@interface DYFSwiftKeychain : NSObject
/// Specifies an access group which is used to share keychain items between applications.
@property (nonatomic, copy) NSString * _Nullable accessGroup;
/// Specifies whether the item is synchronized to other devices through iCloud.
@property (nonatomic) BOOL synchronizable;
/// The identifierfor for kSecAttrService.
@property (nonatomic, copy) NSString * _Nullable serviceIdentifier;
/// Records the query parameters of the last operation.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable queryDictionary;
/// Records the status of the last operation result.
@property (nonatomic) OSStatus osStatus;
/// Instantiates an <code>DYFSwiftKeychain</code> object.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Instantiates a DYFSwiftKeychain object.
/// \param serviceIdentifier The identifier for service.
///
- (nonnull instancetype)initWithServiceIdentifier:(NSString * _Nullable)serviceIdentifier;
/// Creates an instance of DYFSwiftKeychain with the class method.
///
/// returns:
/// An instance of DYFSwiftKeychain.
+ (DYFSwiftKeychain * _Nonnull)createKeychain SWIFT_WARN_UNUSED_RESULT;
/// Returns a keychain that copies the current DYFSwiftKeychain instance.
///
/// returns:
/// A DYFSwiftKeychain object.
- (id _Nonnull)copy SWIFT_WARN_UNUSED_RESULT;
/// Stores or updates the text value in the keychain item by the given key.
/// \param value The text value to be written to the keychain.
///
/// \param key The key which the text is stored in the keychain.
///
///
/// returns:
/// True if the text was successfully written to the keychain, false otherwise.
- (BOOL)add:(NSString * _Nullable)value forKey:(NSString * _Nonnull)key;
/// Stores or updates the text value in the keychain item by the given key.
/// \param value The text value to be written to the keychain.
///
/// \param key The key which the text is stored in the keychain.
///
/// \param options The options indicates when you app needs access to the text in the keychain. By the default DYFSwiftKeychainAccessOptions.accessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.
///
///
/// returns:
/// True if the text was successfully written to the keychain, false otherwise.
- (BOOL)add:(NSString * _Nullable)value forKey:(NSString * _Nonnull)key options:(enum DYFSwiftKeychainAccessOptions)options;
/// Stores or updates the data in the keychain item by the given key.
/// \param value The data to be written to the keychain.
///
/// \param key The key which the data is stored in the keychain.
///
///
/// returns:
/// True if the data was successfully written to the keychain, false otherwise.
- (BOOL)addData:(NSData * _Nullable)value forKey:(NSString * _Nonnull)key;
/// Stores or updates the data in the keychain item by the given key.
/// \param value The data to be written to the keychain.
///
/// \param key The key which the data is stored in the keychain.
///
/// \param options The options indicates when you app needs access to the text in the keychain. By the default DYFSwiftKeychainAccessOptions.accessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.
///
///
/// returns:
/// True if the data was successfully written to the keychain, false otherwise.
- (BOOL)addData:(NSData * _Nullable)value forKey:(NSString * _Nonnull)key options:(enum DYFSwiftKeychainAccessOptions)options;
/// Stores or updates the boolean value in the keychain item by the given key.
/// \param value The boolean value to be written to the keychain.
///
/// \param key The key which the boolean value is stored in the keychain.
///
///
/// returns:
/// True if the boolean value was successfully written to the keychain, false otherwise.
- (BOOL)addBool:(BOOL)value forKey:(NSString * _Nonnull)key;
/// Stores or updates the boolean value in the keychain item by the given key.
/// \param value The boolean value to be written to the keychain.
///
/// \param key The key which the boolean value is stored in the keychain.
///
/// \param options The options indicates when you app needs access to the text in the keychain. By the default DYFSwiftKeychainAccessOptions.accessibleWhenUnlocked option is used that permits the data to be accessed only while the device is unlocked by the user.
///
///
/// returns:
/// True if the boolean value was successfully written to the keychain, false otherwise.
- (BOOL)addBool:(BOOL)value forKey:(NSString * _Nonnull)key options:(enum DYFSwiftKeychainAccessOptions)options;
/// Retrieves the text value from the keychain by the given key.
/// \param key The key that is used to read the keychain item.
///
///
/// returns:
/// The text value from the keychain. Nil if unable to read the item.
- (NSString * _Nullable)get:(NSString * _Nonnull)key;
/// Retrieves the data from the keychain by the given key.
/// \param key The key that is used to read the keychain item.
///
///
/// returns:
/// The data from the keychain. Nil if unable to read the item.
- (NSData * _Nullable)getData:(NSString * _Nonnull)key;
/// Retrieves the data from the keychain by the given key.
/// \param key The key that is used to read the keychain item.
///
/// \param asReference If true, returns the data as reference (needed for things like NEVPNProtocol).
///
///
/// returns:
/// The data from the keychain. Nil if unable to read the item.
- (NSData * _Nullable)getData:(NSString * _Nonnull)key asReference:(BOOL)asReference;
/// Retrieves the boolean value from the keychain by the given key.
/// \param key The key that is used to read the keychain item.
///
///
/// returns:
/// The boolean value from the keychain. False if unable to read the item.
- (BOOL)getBool:(NSString * _Nonnull)key;
/// Deletes the single keychain item by the specified key.
/// \param key The key which is used to delete the keychain item.
///
///
/// returns:
/// True if the item was successfully deleted, false otherwise.
- (BOOL)delete:(NSString * _Nonnull)key;
/// Deletes all keychain items used by the app. Note that this method deletes all items regardless of those used keys.
///
/// returns:
/// True if all keychain items was successfully deleted, false otherwise.
- (BOOL)clear;
@end


/// Used to represent accessible access options.
typedef SWIFT_ENUM(uint8_t, DYFSwiftKeychainAccessOptions, open) {
/// The data in the keychain item can be accessed only while the device is unlocked by the user.
/// This is recommended for items that need to be accessible only while the application is in the foreground. Items with this attribute migrate to a new device when using encrypted backups.
/// This is the default value for keychain items added without explicitly setting an accessibility constant.
  DYFSwiftKeychainAccessOptionsAccessibleWhenUnlocked = 0,
/// The data in the keychain item can be accessed only while the device is unlocked by the user.
/// This is recommended for items that need to be accessible only while the application is in the foreground. Items with this attribute do not migrate to a new device. Thus, after restoring from a backup of a different device, these items will not be present.
  DYFSwiftKeychainAccessOptionsAccessibleWhenUnlockedThisDeviceOnly = 1,
/// The data in the keychain item cannot be accessed after a restart until the device has been unlocked once by the user.
/// After the first unlock, the data remains accessible until the next restart. This is recommended for items that need to be accessed by background applications. Items with this attribute migrate to a new device when using encrypted backups.
  DYFSwiftKeychainAccessOptionsAccessibleAfterFirstUnlock = 2,
/// The data in the keychain item cannot be accessed after a restart until the device has been unlocked once by the user.
/// After the first unlock, the data remains accessible until the next restart. This is recommended for items that need to be accessed by background applications. Items with this attribute do not migrate to a new device. Thus, after restoring from a backup of a different device, these items will not be present.
  DYFSwiftKeychainAccessOptionsAccessibleAfterFirstUnlockThisDeviceOnly = 3,
/// The data in the keychain can only be accessed when the device is unlocked. Only available if a passcode is set on the device.
/// This is recommended for items that only need to be accessible while the application is in the foreground. Items with this attribute never migrate to a new device. After a backup is restored to a new device, these items are missing. No items can be stored in this class on devices without a passcode. Disabling the device passcode causes all items in this class to be deleted.
  DYFSwiftKeychainAccessOptionsAcessibleWhenPasscodeSetThisDeviceOnly = 4,
/// The data in the keychain item can always be accessed regardless of whether the device is locked.
/// This is not recommended for application use. Items with this attribute migrate to a new device when using encrypted backups.
  DYFSwiftKeychainAccessOptionsAccessibleAlways = 5,
/// The data in the keychain item can always be accessed regardless of whether the device is locked.
/// This is not recommended for application use. Items with this attribute do not migrate to a new device. Thus, after restoring from a backup of a different device, these items will not be present.
  DYFSwiftKeychainAccessOptionsAccessibleAlwaysThisDeviceOnly = 6,
};


SWIFT_CLASS("_TtC11eID_SDK_MKV13ErrorTemplate")
@interface ErrorTemplate : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class NSCoder;

SWIFT_CLASS("_TtC11eID_SDK_MKV16GuidelineNFCView")
@interface GuidelineNFCView : UIView
@property (nonatomic, copy) void (^ _Nullable backHandler)(void);
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)setLanguageWithIsEnglish:(BOOL)isEnglish;
@end

enum NFCViewDisplayMessage : NSInteger;

SWIFT_CLASS("_TtC11eID_SDK_MKV13MKIDNFCHelper")
@interface MKIDNFCHelper : NSObject
- (void)getDeviceInfoForRegisterDeviceWithServerUrl:(NSString * _Nonnull)serverUrl successHandler:(void (^ _Nonnull)(NSString * _Nonnull))successHandler errorHandlerSDK:(void (^ _Nonnull)(NSError * _Nonnull))errorHandlerSDK;
- (void)checkAppActivatedWithSuccessHandler:(void (^ _Nonnull)(BOOL))successHandler;
- (void)doActivateWithUrl:(NSString * _Nonnull)url andCustomerId:(NSString * _Nonnull)andCustomerId andBranchId:(NSString * _Nonnull)andBranchId successHandler:(void (^ _Nonnull)(void))successHandler andFailureHandler:(void (^ _Nonnull)(NSError * _Nonnull))andFailureHandler errorHandler:(void (^ _Nonnull)(enum NFCViewDisplayMessage))errorHandler;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC11eID_SDK_MKV16NFCPassportModel") SWIFT_AVAILABILITY(macos,introduced=10.15) SWIFT_AVAILABILITY(ios,introduced=13)
@interface NFCPassportModel : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, NFCPassportReaderError, open) {
  NFCPassportReaderErrorResponseError = 0,
  NFCPassportReaderErrorInvalidResponse = 1,
  NFCPassportReaderErrorUnexpectedError = 2,
  NFCPassportReaderErrorNFCNotSupported = 3,
  NFCPassportReaderErrorNoConnectedTag = 4,
  NFCPassportReaderErrorD087Malformed = 5,
  NFCPassportReaderErrorInvalidResponseChecksum = 6,
  NFCPassportReaderErrorMissingMandatoryFields = 7,
  NFCPassportReaderErrorCannotDecodeASN1Length = 8,
  NFCPassportReaderErrorInvalidASN1Value = 9,
  NFCPassportReaderErrorUnableToProtectAPDU = 10,
  NFCPassportReaderErrorUnableToUnprotectAPDU = 11,
  NFCPassportReaderErrorUnsupportedDataGroup = 12,
  NFCPassportReaderErrorDataGroupNotRead = 13,
  NFCPassportReaderErrorUnknownTag = 14,
  NFCPassportReaderErrorUnknownImageFormat = 15,
  NFCPassportReaderErrorNotImplemented = 16,
  NFCPassportReaderErrorTagNotValid = 17,
  NFCPassportReaderErrorConnectionError = 18,
  NFCPassportReaderErrorUserCanceled = 19,
  NFCPassportReaderErrorInvalidMRZKey = 20,
  NFCPassportReaderErrorMoreThanOneTagFound = 21,
  NFCPassportReaderErrorInvalidHashAlgorithmSpecified = 22,
  NFCPassportReaderErrorInvalidDataPassed = 23,
  NFCPassportReaderErrorNotYetSupported = 24,
};

/// /
/// /  NFCViewDisplayMessage.swift
/// /  NFCPassportReader
/// /
/// /  Created by Andy Qua on 09/02/2021.
/// /
typedef SWIFT_ENUM(NSInteger, NFCViewDisplayMessage, open) {
  NFCViewDisplayMessageLicenseExpires = -1,
  NFCViewDisplayMessageSUUCESS = 0,
  NFCViewDisplayMessageMoCSuucess = 304,
  NFCViewDisplayMessageSuccessfulRead = 5,
  NFCViewDisplayMessageErrorTransactionID = 13,
  NFCViewDisplayMessageNOT_SUUCESS = 93,
  NFCViewDisplayMessageCARD_TIMEOUT = 203,
  NFCViewDisplayMessageCREATE_TEMPLATE_ERROR = 213,
  NFCViewDisplayMessageCREATE_TEMPLATE_ERROR_SERVER = 300,
  NFCViewDisplayMessageVERIFY_MOC_SERVER_ERROR = 301,
  NFCViewDisplayMessageICAO_ERROR = 302,
  NFCViewDisplayMessageVERIFY_SOD_SERVER_ERROR = 303,
  NFCViewDisplayMessageNOT_ACTIVATED = 600,
  NFCViewDisplayMessageFAILED_TO_VERIFY_SOD = 601,
  NFCViewDisplayMessagePARSE_TEMPLATE_ERROR = 214,
  NFCViewDisplayMessageVERIFY_MOC_FAILED_WRONG_FACE = 403,
  NFCViewDisplayMessageError_connect_server = 7,
  NFCViewDisplayMessageSETAPPID = 404,
  NFCViewDisplayMessageNo_face_data = 299,
  NFCViewDisplayMessageSEND_LATER_MOC_ERROR = 406,
  NFCViewDisplayMessageGet_Data_MoC = 407,
};



@protocol UpdateReaderSessionMessageDelegate;

SWIFT_CLASS("_TtC11eID_SDK_MKV14PassportReader") SWIFT_AVAILABILITY(ios,introduced=13)
@interface PassportReader : NSObject
@property (nonatomic, weak) id <UpdateReaderSessionMessageDelegate> _Nullable delegate;
- (void)readIdInfoWithNfcPopupTitle:(NSString * _Nonnull)nfcPopupTitle;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end







SWIFT_AVAILABILITY(ios,introduced=13)
@interface PassportReader (SWIFT_EXTENSION(eID_SDK_MKV))
- (void)showReaderMessage:(NSString * _Nonnull)value;
- (void)errorReaderMessage:(NSString * _Nonnull)value;
@end




SWIFT_CLASS("_TtC11eID_SDK_MKV13PassportUtils")
@interface PassportUtils : NSObject
- (NSString * _Nonnull)getMRZKeyWithPassportNumber:(NSString * _Nonnull)passportNumber dateOfBirth:(NSString * _Nonnull)dateOfBirth dateOfExpiry:(NSString * _Nonnull)dateOfExpiry SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_PROTOCOL("_TtP11eID_SDK_MKV34UpdateReaderSessionMessageDelegate_") SWIFT_AVAILABILITY(ios,introduced=13)
@protocol UpdateReaderSessionMessageDelegate
- (void)showMessageWithAlertMessage:(enum NFCViewDisplayMessage)alertMessage;
- (void)errorMessage:(enum NFCViewDisplayMessage)value;
- (void)errorCard:(enum NFCPassportReaderError)value;
- (void)getInfoCard:(CardInfo * _Nonnull)value;
- (void)getSODresult:(enum NFCViewDisplayMessage)value;
- (void)closeNfcPopUp;
@end

#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
